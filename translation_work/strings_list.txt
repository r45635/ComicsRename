ComicsRename - Extracted Strings for Translation\n==================================================\n\n  1. 
        ]
        
        return any(indicator in line_content for indicator in ui_indicators)
    
    def _get_line_number(self, content: str, position: int) -> int:
        \n  2. 
        matches = re.finditer(pattern, content, re.MULTILINE)
        
        for match in matches:
            string_val = match.group(1)
            if self._is_translatable_string(string_val):
                strings.add(string_val)
                self._add_context(string_val, file_path, self._get_line_number(content, match.start()))
        
        return strings
    
    def _extract_user_messages(self, content: str, file_path: str) -> Set[str]:
        \n  3. 
        strings = set()
        
        pattern = r\n  4. 
        strings = set()
        
        patterns = [
            r\n  5.    (Allez dans votre profil ‚Üí API pour g√©n√©rer une cl√©)\n  6.    (Ils seront stock√©s dans .env, prot√©g√© par .gitignore)\n  7.    ... and {len(results[\n  8.    ... et {len(albums) - 3} autres albums\n  9.    ./launch.sh       (macOS/Linux)\n 10.    1. Lancez l\n 11.    1. Premi√®re recherche: Cr√©ation session + authentification\n 12.    1. üñ±Ô∏è  Double-clic sur le nom du dossier\n 13.    2. Ouvrez un dossier avec des fichiers\n 14.    2. Recherches suivantes: R√©utilisation de la session existante\n 15.    2. ‚úèÔ∏è  Passage en mode √©dition (fond jaune, bordure bleue)\n 16.    3. Double-cliquez sur le nom du dossier en haut\n 17.    3. En cas d\n 18.    3. ‚å®Ô∏è  Saisie du nouveau nom du dossier\n 19.    4. Changement d\n 20.    4. Modifiez le nom et appuyez sur Entr√©e\n 21.    4. ‚úÖ Validation par Entr√©e ou perte de focus\n 22.    5. üîç V√©rification que le nouveau nom est valide\n 23.    6. ‚ùì Demande de confirmation √† l\n 24.    7. üìÅ Renommage effectif du dossier\n 25.    8. üîÑ Rechargement des fichiers dans le nouveau dossier\n 26.    9. üìç Mise √† jour des param√®tres (last_folder)\n 27.    Assurez-vous que bdgest_scraper_api.py est dans le m√™me r√©pertoire.\n 28.    BDGEST_PASSWORD=votre_mot_de_passe\n 29.    BDGEST_USERNAME=votre_nom_utilisateur\n 30.    Donn√©es de la s√©rie: {first_series}\n 31.    Fichier de log: {args.log_file}\n 32.    Files processed: {results[\n 33.    Mode debug: {debug_mode}\n 34.    Mode verbose: {args.verbose}\n 35.    Strings found: {results[\n 36.    Terme de recherche: \n 37.    Utilisateur: {username}\n 38.    Utilisez -u/-p ou cr√©ez un fichier .env avec:\n 39.    Utilisez les variables d\n 40.    Vous pouvez maintenant utiliser ComicsRename en toute s√©curit√©.\n 41.    ou cr√©ez un fichier .env avec:\n 42.    pip install -r requirements.txt\n 43.    pip install PySide6 requests beautifulsoup4 lxml python-dotenv\n 44.    python main.py\n 45.    {i+1}. {album_name} (#{album_number}) - {album_date}\n 46.    {i:2d}. {string_val}\n 47.    {i}. {issue}\n 48.    ‚Ä¢ Annulation possible avec √âchap\n 49.    ‚Ä¢ Authentification uniquement quand n√©cessaire\n 50.    ‚Ä¢ Confirmation obligatoire de l\n 51.    ‚Ä¢ Entr√©e: Valider le nouveau nom\n 52.    ‚Ä¢ Gestion automatique des erreurs d\n 53.    ‚Ä¢ Gestion des erreurs (permissions, etc.)\n 54.    ‚Ä¢ Mode lecture: Aspect normal\n 55.    ‚Ä¢ Mode √©dition: Fond jaune, bordure bleue\n 56.    ‚Ä¢ Performance am√©lior√©e pour les recherches multiples\n 57.    ‚Ä¢ Perte de focus: Valider le nouveau nom\n 58.    ‚Ä¢ Restauration du nom original en cas d\n 59.    ‚Ä¢ R√©utilisation des cookies et tokens\n 60.    ‚Ä¢ Session persistante entre les recherches\n 61.    ‚Ä¢ S√©lection automatique du texte en mode √©dition\n 62.    ‚Ä¢ Validation du nom (caract√®res autoris√©s)\n 63.    ‚Ä¢ V√©rification de l\n 64.    ‚Ä¢ extracted_strings.json    - Complete extraction data\n 65.    ‚Ä¢ strings_list.txt         - Simple list for reference\n 66.    ‚Ä¢ translation_template.json - Template for translators\n 67.    ‚Ä¢ {failed}\n 68.    ‚Ä¢ √âchap: Annuler et restaurer le nom original\n 69.    ‚ö†Ô∏è  .env file is empty\n 70.    ‚ö†Ô∏è  .env file not found (optional)\n 71.    ‚úÖ .env file exists\n 72.    ‚úÖ .env file has content\n 73.    ‚úÖ .env.example template exists\n 74.    ‚úÖ ComicRenamer class found\n 75.    ‚úÖ PySide6 GUI components available\n 76.    ‚úÖ Python {version.major}.{version.minor}.{version.micro} (OK)\n 77.    ‚úÖ setup_credentials.py exists\n 78.    ‚úÖ {file_name}\n 79.    ‚úÖ {module_name}: {description}\n 80.    ‚úÖ {package_name}: {version}\n 81.    ‚ùå .env.example template missing\n 82.    ‚ùå ComicRenamer class not found\n 83.    ‚ùå Error reading .env file: {e}\n 84.    ‚ùå GUI components unavailable: {e}\n 85.    ‚ùå Python {version.major}.{version.minor}.{version.micro} (Required: 3.8+)\n 86.    ‚ùå setup_credentials.py missing\n 87.    ‚ùå {file_name}: Missing\n 88.    ‚ùå {module_name}: {description} - {e}\n 89.    ‚ùå {package_name}: Not installed\n 90.   10. üì¢ Message de confirmation\n 91.   [Issue {i}] id={issue.get(\n 92.   [Series {i}] id={series.get(\n 93.   {key}: {\n 94.   {key}: {value}\n 95.  existe d√©j√† dans ce dossier.\n 96.  existe d√©j√† dans ce r√©pertoire.\n 97.  in str(ctx):
                notes.append(\n 98. )

    def _enable_folder_rename_btn(self, *args):
        self.folder_rename_btn.setEnabled(True)

    def _on_album_selection_changed(self, selected, deselected):
        # Enable if any row is selected, else disable
        selected_rows = self.album_table.selectionModel().selectedRows()
        self.folder_rename_btn.setEnabled(bool(selected_rows))

    def _on_series_selection_changed(self, txt):
        \n 99. )

    def _enable_folder_rename_btn(self, *args):
        self.folder_rename_btn.setEnabled(True)

    def _on_album_selection_changed(self, selected, deselected):
        # Enable if any row is selected, else disable
        selected_rows = self.album_table.selectionModel().selectedRows()
        self.folder_rename_btn.setEnabled(bool(selected_rows))

    def _populate_albums(self, txt):
        if not txt:
            return
        self.album_table.clearContents()
        self.album_table.setRowCount(0)
        self.series_cover_url = \n100. )

class AlbumTable(QTableWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.main = parent
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.setDragEnabled(True)
        self.setColumnCount(1)
        self.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self._show_context_menu)

    def mouseMoveEvent(self, event):
        it = self.itemAt(event.pos())
        if not it:
            return
        print(f\n101. )
                    continue
                # Nettoie le nom du fichier (enl√®ve les caract√®res interdits)
                base_name = os.path.basename(src).replace(\n102. )
                    return
                for s in sorted(self.issues_by_series):
                    self.series_combo.addItem(f\n103. )
                else:
                    # Clear album table since we\n104. )
                self.issues_by_series = issues_by_series
                if not issues_by_series:
                    QMessageBox.warning(self, \n105. )
            else:
                print(f\n106. )
            return
        # Build new filename
        series = meta.get(\n107. )
            return
        # Clean up names
        clean = lambda s: \n108. )
            return
        current_folder = pathlib.Path(self.files[0][\n109. )
            return
        f = self.files[fr]
        itm = self.album_table.item(ar, 0)
        meta = itm.data(Qt.UserRole) if itm else None
        if not meta:
            QMessageBox.critical(self, \n110. )
            return
        if QMessageBox.question(self, \n111. )
            return
        itm = self.album_table.item(ar, 0)
        meta = itm.data(Qt.UserRole) if itm else None
        if not meta:
            QMessageBox.critical(self, \n112. )
        elif action == reveal_action:
            try:
                subprocess.Popen([\n113. )
        else:
            albums = []
            for album in series_list:
                s = album.get(\n114. )
        else:  # BDGest
            # Check if SeriesName checkbox is checked
            if self.series_name_cb.isChecked():
                # Use series-only search
                series_results = provider.search_series_only(q, debug=debug, verbose=verbose) \
                    if hasattr(provider, \n115. )
        for w in (self.source_combo, self.search_bar, self.search_btn, self.dir_btn, self.recursive_cb, self.settings_btn):
            ctrl.addWidget(w)
        layout.addLayout(ctrl)

        splitter_main = QSplitter(Qt.Horizontal)

        # --- Folder display ---
        file_panel = QWidget()
        file_panel_layout = QVBoxLayout(file_panel)
        file_panel_layout.setContentsMargins(0, 0, 0, 0)
        folder_display_layout = QHBoxLayout()
        self.folder_display = DraggableLineEdit()
        # Add the rename folder button
        self.folder_rename_btn = QPushButton(\n116. )
        self.dir_btn = QPushButton(\n117. )
        self.folder_rename_btn.setFixedWidth(30)
        self.folder_rename_btn.setEnabled(False)  # Disabled by default
        self.folder_rename_btn.clicked.connect(self._rename_folder_to_serie)
        folder_display_layout.addWidget(self.folder_display)
        folder_display_layout.addWidget(self.folder_rename_btn)
        file_panel_layout.addLayout(folder_display_layout)
        self.file_table = FileTable(self)
        self.file_table.setColumnCount(4)
        self.file_table.setHorizontalHeaderLabels([\n118. )
        self.folder_rename_btn.setToolTip(\n119. )
        self.folder_rename_btn.setToolTip(tr(\n120. )
        self.layout = QFormLayout(self)

        self.settings = settings or QSettings(\n121. )
        self.recursive_cb = QCheckBox(\n122. )
        self.rename_btn = QPushButton(\n123. )
        self.resize(1400, 800)
        self.settings = QSettings(\n124. )
        self.settings_btn.setFixedWidth(30)
        self.settings_btn.setToolTip(\n125. )
        self.settings_btn.setFixedWidth(30)
        self.settings_btn.setToolTip(tr(\n126. ))
                    return
                for s in sorted(self.issues_by_series):
                    self.series_combo.addItem(f\n127. ))
                return
            import shutil
            for src in files_to_add:
                # V√©rifie que le fichier existe
                if not os.path.exists(src):
                    QMessageBox.critical(self, tr(\n128. ))
                return
            op = \n129. ))
            return
        # Clean up names
        clean = lambda s: \n130. ))
            return
        # Extract serie_name
        serie_name = meta.get(\n131. ))
            return
        current_folder = pathlib.Path(self.files[0][\n132. ))
            return
        itm = self.album_table.item(ar, 0)
        meta = itm.data(Qt.UserRole) if itm else None
        if not meta:
            QMessageBox.critical(self, tr(\n133. ))
            self._cancel_editing()
            return
        
        # Check if folder with new name already exists
        new_folder_path = self._original_folder_path.parent / cleaned_name
        if new_folder_path.exists():
            QMessageBox.critical(self.main_window, tr(\n134. ))
        for w in (self.source_combo, self.search_bar, self.search_btn, self.dir_btn, self.recursive_cb, self.series_name_cb, self.settings_btn):
            ctrl.addWidget(w)
        layout.addLayout(ctrl)

        splitter_main = QSplitter(Qt.Horizontal)

        # --- Folder display ---
        file_panel = QWidget()
        file_panel_layout = QVBoxLayout(file_panel)
        file_panel_layout.setContentsMargins(0, 0, 0, 0)
        folder_display_layout = QHBoxLayout()
        self.folder_display = EditableFolderLineEdit(main_window=self)
        # Add the rename folder button
        self.folder_rename_btn = QPushButton(\n135. ))
        self.dir_btn = QPushButton(tr(\n136. ))
        self.folder_rename_btn.setFixedWidth(30)
        self.folder_rename_btn.setEnabled(False)  # Disabled by default
        self.folder_rename_btn.clicked.connect(self._rename_folder_to_serie)
        folder_display_layout.addWidget(self.folder_display)
        folder_display_layout.addWidget(self.folder_rename_btn)
        file_panel_layout.addLayout(folder_display_layout)
        self.file_table = FileTable(self)
        self.file_table.setColumnCount(4)
        self.file_table.setHorizontalHeaderLabels([\n137. ))
        self.layout = QFormLayout(self)

        self.settings = settings or QSettings(\n138. ))
        self.recursive_cb = QCheckBox(\n139. ))
        self.rename_btn = QPushButton(tr(\n140. ))
        self.resize(1400, 800)
        self.settings = QSettings(\n141. ))
        self.series_name_cb.setVisible(False)  # Hidden by default, shown only for BDGest
        self.settings_btn = QPushButton(\n142. )))

    def _rename_folder_to_serie(self):
        # Get current folder path
        if not self.files:
            QMessageBox.warning(self, \n143. )))

    def _rename_folder_to_serie(self):
        # Get current folder path
        if not self.files:
            QMessageBox.warning(self, tr(\n144. )))
        else:
            # If nothing selected, show root folder name
            self.folder_display.setText(os.path.basename(self.settings.value(\n145. ), str(e))

    def _open_settings(self):
        dlg = SettingsDialog(self, self.settings)
        if dlg.exec():
            # Invalidate BDGest session when settings change (credentials might have changed)
            bdgest_provider = PROVIDERS.get(\n146. ), str(e))
            return

        # External file drop (from Finder, etc.)
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            supported_exts = (\n147. ), tr(\n148. ).rstrip(\n149. ,
            r\n150. ,
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, content, re.MULTILINE)
            for match in matches:
                string_val = match.group(1)
                if self._is_translatable_string(string_val):
                    strings.add(string_val)
                    self._add_context(string_val, file_path, self._get_line_number(content, match.start()))
        
        return strings
    
    def _extract_ui_strings(self, content: str, file_path: str) -> Set[str]:
        \n151. , error=str(e)))
                self._cancel_editing()
                return
        
        # Reset to read-only mode
        self._reset_to_readonly()

    def _cancel_editing(self):
        \n152. , f\n153. , msg, QMessageBox.Yes | QMessageBox.No) != QMessageBox.Yes:
                return
            dest_folder = self.main.files[0][\n154. , msg, QMessageBox.Yes | QMessageBox.No) == QMessageBox.Yes:
            try:
                if not os.path.exists(str(f[\n155. , name=cleaned_name))
                
            except Exception as e:
                QMessageBox.critical(self.main_window, tr(\n156. , name=cleaned_name))
            self._cancel_editing()
            return
        
        # Confirm rename
        reply = QMessageBox.question(
            self.main_window,
            tr(\n157. , name=new_name))
                        return
                    os.rename(f[\n158. , name=new_name))
            return
        if QMessageBox.question(self, tr(\n159. , new_name=new_name), QMessageBox.Yes | QMessageBox.No) == QMessageBox.Yes:
            try:
                if not os.path.exists(str(f[\n160. , path=f[\n161. , path=src))
                    continue
                # Nettoie le nom du fichier (enl√®ve les caract√®res interdits)
                base_name = os.path.basename(src).replace(\n162. , str(e))

    def _show_context_menu(self, pos):
        row = self.rowAt(pos.y())
        if row < 0:
            return
        menu = QMenu(self)
        open_action = menu.addAction(\n163. /\\\n164. Ajouter des fichiers\n165. Album metadata missing\n166. Application Settings\n167. Aucun album trouv√© pour cette recherche sur BDGest.\n168. Aucun album trouv√© pour cette recherche.\n169. Aucun dossier actif pour l\n170. Aucun fichier dans le dossier.\n171. Aucun r√©sultat\n172. Aucune s√©rie trouv√©e pour cette recherche sur BDGest.\n173. Avertissement\n174. Comic Renamer - Multi-Source\n175. ComicsRename String Extraction Tool\n176. Constructed URL: {url}\n177. Could not open file:\n{e}\n178. Could not reveal file:\n{e}\n179. Couverture: {series[\n180. Dernier dossier utilis√©\n181. Details: {e}\n182. Disques externes (/Volumes)\n183. Dossier personnel\n184. Dossier renomm√© en :\n{new_folder_name}\n185. Encoded Name: {encoded_series_name}\n186. Erreur\n187. Erreur lors du renommage du dossier :\n{e}\n188. Error\n189. Error processing {file_path}: {e}\n190. Error starting application: {e}\n191. Error: Missing dependencies. Please install requirements:\n192. Expected URL: {expected_url}\n193. Extract strings from QMessageBox calls\n194. Extract strings from addItem calls\n195. Extracting from: {file_path}\n196. Format non support√©\n197. Impossible de d√©terminer le nom de la s√©rie.\n198. Info\n199. La fonction fetch_albums_by_series_id r√©cup√®re maintenant les d√©tails des albums\n200. La fonctionnalit√© de renommage par double-clic est op√©rationnelle.\n201. Language Change\n202. Language will be applied after restarting the application.\n203. Le dossier porte d√©j√† ce nom.\n204. Le fichier source n\n205. Le syst√®me de gestion de session est op√©rationnel.\n206. Mot de passe configur√©: {\n207. M√©tadonn√©es de l\n208. No Results\n209. No albums found for this search.\n210. Nom: {series[\n211. O√π souhaitez-vous commencer la navigation ?\n212. Param√®tres\n213. Param√®tres de BDGestProvider.search_albums_by_series_id: {provider_params}\n214. Param√®tres de get_bdgest_albums_by_series_id: {params}\n215. Pays: {series[\n216. Please select one file and one album\n217. Rename\n218. Rename Error\n219. Renommer le dossier\n220. Renommer le dossier avec le nom de la s√©rie s√©lectionn√©e\n221. R√©sultat\n222. Scanning directory: {script_dir}\n223. Selection\n224. Series ID: {series_id}\n225. Series Name: {series_name}\n226. Seuls les fichiers PDF, EPUB, CBZ ou CBR sont accept√©s.\n227. Succ√®s\n228. S√©lection\n229. S√©lection du dossier\n230. Translation template saved to: {output_file}\n231. URL: {series[\n232. Un dossier nomm√© \n233. Un fichier nomm√© \n234. Utilisateur configur√©: {\n235. Valeur par d√©faut fetch_details dans provider: {provider_default}\n236. Valeur par d√©faut fetch_details: {default_fetch_details}\n237. Valeur par d√©faut max_workers: {default_max_workers}\n238. Veuillez s√©lectionner un album dans la liste.\n239. \nD√©tails complets:\n240. \nFor installation help, see:\n241. \nOr use the launcher scripts:\n242. \nPlease fix the issues above.\n243. \nTo start the application, run:\n244. \n‚å®Ô∏è Raccourcis clavier:\n245. \n‚öôÔ∏è  Checking configuration...\n246. \n‚úÖ All tests passed!\n247. \n‚úÖ Structure des fonctions correcte !\n248. \n‚úÖ Test termin√© avec succ√®s!\n249. \n‚úÖ Tests r√©ussis! La fonctionnalit√© de r√©cup√©ration d\n250. \n‚ùå Certains tests ont √©chou√©.\n251. \n‚ùå Test √©chou√©.\n252. \nüéâ Test r√©ussi!\n253. \nüéâ Tous les tests r√©ussis !\n254. \nüé® Indicateurs visuels:\n255. \nüéØ Top 10 strings to translate:\n256. \nüí° If dependencies are missing, try:\n257. \nüí° Pour tester:\n258. \nüìÅ Checking project files...\n259. \nüìÅ Output files created in: {output_dir}\n260. \nüìä Extraction Results:\n261. \nüìã Avantages de la nouvelle impl√©mentation:\n262. \nüìã Workflow complet:\n263. \nüìö Albums trouv√©s:\n264. \nüìö S√©rie #{i}\n265. \nüì¶ Checking dependencies...\n266. \nüîÑ Comportement:\n267. \nüîç Fonctionnalit√©s d\n268. \nüîç Test des m√©thodes de gestion de session:\n269. \nüîç Testing function availability...\n270. \nüîë Test de r√©cup√©ration des identifiants:\n271. \nüîß Testing module imports...\n272. \nüñ•Ô∏è  Checking GUI availability...\n273. \nüõ°Ô∏è Protections impl√©ment√©es:\n274. ])
        default_provider = self.settings.value(\n275. ])
        idx = self.provider_combo.findText(self.default_provider)
        if idx >= 0:
            self.provider_combo.setCurrentIndex(idx)
        self.provider_combo.setCurrentIndex(idx if idx >= 0 else 0)

        self.files = []
        self._source = self.provider_combo.currentText()
        self.issues_by_series = defaultdict(list)
        self._populating = False
        self._bdgest_album_results = []
        self._bdgest_series_results = []  # New: store series search results
        self._original_cover_pixmap = None  # Store original pixmap for rescaling
        self._build_ui()
        self.series_cover_url = \n276. ])
        idx = self.provider_combo.findText(self.default_provider)
        if idx >= 0:
            self.provider_combo.setCurrentIndex(idx)
        self.provider_combo.setCurrentIndex(idx if idx >= 0 else 0)

        self.files = []
        self._source = self.provider_combo.currentText()
        self.issues_by_series = defaultdict(list)
        self._populating = False
        self._bdgest_album_results = []
        self._build_ui()
        self.series_cover_url = \n277. ])
        self.search_bar = DroppableLineEdit()
        self.search_btn = QPushButton(\n278. ])
        self.search_bar = DroppableLineEdit()
        self.search_btn = QPushButton(tr(\n279. ]))
                        return
                    if new_path.exists():
                        QMessageBox.critical(self, tr(\n280. ]))
                    return
                os.rename(str(f[\n281. ]}\n282. album manquantes.\n283. exactement comme fetch_albums.\n284. existe pas:\n{f[\n285. import.\n286. pip install -r requirements.txt\n287. {new_name}\n288. √âtat initial - Authentifi√©: {provider._authenticated}\n289. √âtat initial - Derniers identifiants: {provider._last_credentials}\n290. √âtat initial - Session: {provider._session}\n291. ‚è∞ D√©but: {datetime.now().strftime(\n292. ‚è±Ô∏è  Dur√©e: {(end_time - start_time).total_seconds():.2f}s\n293. ‚ö†Ô∏è  Cl√© ComicVine manquante (optionnel pour BDGest seulement)\n294. ‚ö†Ô∏è  Fichier .env manquant\n295. ‚ö†Ô∏è  {var} manquant\n296. ‚úÖ .env prot√©g√© dans .gitignore\n297. ‚úÖ BDGestProvider cr√©√©\n298. ‚úÖ BDGestProvider utilise fetch_details=True par d√©faut\n299. ‚úÖ BDGestProvider.search_albums_by_series_id method available\n300. ‚úÖ Classes import√©es avec succ√®s\n301. ‚úÖ Configuration sauvegard√©e dans .env\n302. ‚úÖ Fichier .env trouv√©\n303. ‚úÖ Import de get_bdgest_albums_by_series_id r√©ussi\n304. ‚úÖ Param√®tre fetch_details pr√©sent\n305. ‚úÖ Param√®tre max_workers pr√©sent\n306. ‚úÖ Series ID correctly placed in \n307. ‚úÖ Series name correctly placed in \n308. ‚úÖ fetch_details=True par d√©faut\n309. ‚úÖ get_bdgest_albums_by_series_id imported successfully\n310. ‚úÖ max_workers=4 par d√©faut\n311. ‚úÖ {len(albums)} album(s) trouv√©(s) pour la s√©rie \n312. ‚úÖ {len(series_list)} s√©rie(s) trouv√©e(s):\n313. ‚úÖ {len(series_results)} s√©rie(s) trouv√©e(s)\n314. ‚úÖ {method} disponible\n315. ‚úÖ {method}: {description}\n316. ‚úÖ {var} configur√©\n317. ‚ùå .env non prot√©g√© dans .gitignore\n318. ‚ùå .gitignore manquant\n319. ‚ùå Aucun ID de s√©rie trouv√© dans les r√©sultats\n320. ‚ùå Aucun album trouv√© pour la s√©rie \n321. ‚ùå Aucune s√©rie trouv√©e pour \n322. ‚ùå Aucune s√©rie trouv√©e.\n323. ‚ùå BDGestProvider devrait utiliser fetch_details=True par d√©faut\n324. ‚ùå BDGestProvider.search_albums_by_series_id method not found\n325. ‚ùå Configuration annul√©e.\n326. ‚ùå Erreur d\n327. ‚ùå Erreur lors de la r√©cup√©ration des identifiants: {e}\n328. ‚ùå Erreur lors de la sauvegarde: {e}\n329. ‚ùå Erreur lors des tests: {e}\n330. ‚ùå Erreur lors du test: {e}\n331. ‚ùå Erreur: Nom d\n332. ‚ùå Error during testing: {e}\n333. ‚ùå Identifiants BDGest manquants.\n334. ‚ùå Param√®tre fetch_details manquant\n335. ‚ùå Param√®tre max_workers manquant\n336. ‚ùå Series ID not found in \n337. ‚ùå Series name not found in \n338. ‚ùå fetch_details devrait √™tre True par d√©faut\n339. ‚ùå max_workers devrait √™tre 4 par d√©faut\n340. ‚ùå {len(failed_checks)} check(s) failed:\n341. ‚ùå {method} manquante\n342. ‚ùå {method}: MANQUANT\n343. üéâ All checks passed! ComicsRename is ready to use.\n344. üéâ Configuration de s√©curit√© optimale !\n345. üéâ Configuration termin√©e !\n346. üêç Checking Python version...\n347. üìù Les albums r√©cup√©r√©s auront maintenant un champ \n348. üìù Veuillez entrer vos identifiants:\n349. üîç ComicsRename Installation Validator\n350. üîç Recherche de s√©ries avec le terme: \n351. üîç Test 1: Recherche de s√©ries...\n352. üîç Test 2: R√©cup√©ration des albums pour la s√©rie \n353. üîç Test de la structure des donn√©es d\n354. üîç Testing URL construction...\n355. üîç V√©rification de S√©curit√©\n356. üîê Configuration S√©curis√©e des Identifiants\n357. üîí Permissions s√©curis√©es appliqu√©es\n358. üîß Actions Recommand√©es:\n359. üîß Param√®tres de test:\n360. üî∏ BDGest (www.bedetheque.com)\n361. üî∏ ComicVine (comicvine.gamespot.com)\n362. üß™ Test de gestion de session BDGest\n363. üß™ Test de renommage de dossier par double-clic\n364. üß™ Test de r√©cup√©ration d\n365. üß™ Test de r√©cup√©ration des d√©tails d\n