ComicsRename - Extracted Strings for Translation\n==================================================\n\n  1. 
        ]
        
        return any(indicator in line_content for indicator in ui_indicators)
    
    def _get_line_number(self, content: str, position: int) -> int:
        \n  2. 
        matches = re.finditer(pattern, content, re.MULTILINE)
        
        for match in matches:
            string_val = match.group(1)
            if self._is_translatable_string(string_val):
                strings.add(string_val)
                self._add_context(string_val, file_path, self._get_line_number(content, match.start()))
        
        return strings
    
    def _extract_user_messages(self, content: str, file_path: str) -> Set[str]:
        \n  3. 
        strings = set()
        
        pattern = r\n  4. 
        strings = set()
        
        patterns = [
            r\n  5.    (Allez dans votre profil â†’ API pour gÃ©nÃ©rer une clÃ©)\n  6.    (Ils seront stockÃ©s dans .env, protÃ©gÃ© par .gitignore)\n  7.    ... and {len(results[\n  8.    ... et {len(albums) - 3} autres albums\n  9.    ./launch.sh       (macOS/Linux)\n 10.    1. Lancez l\n 11.    1. PremiÃ¨re recherche: CrÃ©ation session + authentification\n 12.    1. ğŸ–±ï¸  Double-clic sur le nom du dossier\n 13.    2. Ouvrez un dossier avec des fichiers\n 14.    2. Recherches suivantes: RÃ©utilisation de la session existante\n 15.    2. âœï¸  Passage en mode Ã©dition (fond jaune, bordure bleue)\n 16.    3. Double-cliquez sur le nom du dossier en haut\n 17.    3. En cas d\n 18.    3. âŒ¨ï¸  Saisie du nouveau nom du dossier\n 19.    4. Changement d\n 20.    4. Modifiez le nom et appuyez sur EntrÃ©e\n 21.    4. âœ… Validation par EntrÃ©e ou perte de focus\n 22.    5. ğŸ” VÃ©rification que le nouveau nom est valide\n 23.    6. â“ Demande de confirmation Ã  l\n 24.    7. ğŸ“ Renommage effectif du dossier\n 25.    8. ğŸ”„ Rechargement des fichiers dans le nouveau dossier\n 26.    9. ğŸ“ Mise Ã  jour des paramÃ¨tres (last_folder)\n 27.    Assurez-vous que bdgest_scraper_api.py est dans le mÃªme rÃ©pertoire.\n 28.    BDGEST_PASSWORD=votre_mot_de_passe\n 29.    BDGEST_USERNAME=votre_nom_utilisateur\n 30.    DonnÃ©es de la sÃ©rie: {first_series}\n 31.    Fichier de log: {args.log_file}\n 32.    Files processed: {results[\n 33.    Mode debug: {debug_mode}\n 34.    Mode verbose: {args.verbose}\n 35.    Strings found: {results[\n 36.    Terme de recherche: \n 37.    Utilisateur: {username}\n 38.    Utilisez -u/-p ou crÃ©ez un fichier .env avec:\n 39.    Utilisez les variables d\n 40.    Vous pouvez maintenant utiliser ComicsRename en toute sÃ©curitÃ©.\n 41.    ou crÃ©ez un fichier .env avec:\n 42.    pip install -r requirements.txt\n 43.    pip install PySide6 requests beautifulsoup4 lxml python-dotenv\n 44.    python main.py\n 45.    {i+1}. {album_name} (#{album_number}) - {album_date}\n 46.    {i:2d}. {string_val}\n 47.    {i}. {issue}\n 48.    â€¢ Annulation possible avec Ã‰chap\n 49.    â€¢ Authentification uniquement quand nÃ©cessaire\n 50.    â€¢ Confirmation obligatoire de l\n 51.    â€¢ EntrÃ©e: Valider le nouveau nom\n 52.    â€¢ Gestion automatique des erreurs d\n 53.    â€¢ Gestion des erreurs (permissions, etc.)\n 54.    â€¢ Mode lecture: Aspect normal\n 55.    â€¢ Mode Ã©dition: Fond jaune, bordure bleue\n 56.    â€¢ Performance amÃ©liorÃ©e pour les recherches multiples\n 57.    â€¢ Perte de focus: Valider le nouveau nom\n 58.    â€¢ Restauration du nom original en cas d\n 59.    â€¢ RÃ©utilisation des cookies et tokens\n 60.    â€¢ Session persistante entre les recherches\n 61.    â€¢ SÃ©lection automatique du texte en mode Ã©dition\n 62.    â€¢ Validation du nom (caractÃ¨res autorisÃ©s)\n 63.    â€¢ VÃ©rification de l\n 64.    â€¢ extracted_strings.json    - Complete extraction data\n 65.    â€¢ strings_list.txt         - Simple list for reference\n 66.    â€¢ translation_template.json - Template for translators\n 67.    â€¢ {failed}\n 68.    â€¢ Ã‰chap: Annuler et restaurer le nom original\n 69.    âš ï¸  .env file is empty\n 70.    âš ï¸  .env file not found (optional)\n 71.    âœ… .env file exists\n 72.    âœ… .env file has content\n 73.    âœ… .env.example template exists\n 74.    âœ… ComicRenamer class found\n 75.    âœ… PySide6 GUI components available\n 76.    âœ… Python {version.major}.{version.minor}.{version.micro} (OK)\n 77.    âœ… setup_credentials.py exists\n 78.    âœ… {file_name}\n 79.    âœ… {module_name}: {description}\n 80.    âœ… {package_name}: {version}\n 81.    âŒ .env.example template missing\n 82.    âŒ ComicRenamer class not found\n 83.    âŒ Error reading .env file: {e}\n 84.    âŒ GUI components unavailable: {e}\n 85.    âŒ Python {version.major}.{version.minor}.{version.micro} (Required: 3.8+)\n 86.    âŒ setup_credentials.py missing\n 87.    âŒ {file_name}: Missing\n 88.    âŒ {module_name}: {description} - {e}\n 89.    âŒ {package_name}: Not installed\n 90.   10. ğŸ“¢ Message de confirmation\n 91.   [Issue {i}] id={issue.get(\n 92.   [Series {i}] id={series.get(\n 93.   {key}: {\n 94.   {key}: {value}\n 95.  existe dÃ©jÃ  dans ce dossier.\n 96.  existe dÃ©jÃ  dans ce rÃ©pertoire.\n 97.  in str(ctx):
                notes.append(\n 98. )

    def _enable_folder_rename_btn(self, *args):
        self.folder_rename_btn.setEnabled(True)

    def _on_album_selection_changed(self, selected, deselected):
        # Enable if any row is selected, else disable
        selected_rows = self.album_table.selectionModel().selectedRows()
        self.folder_rename_btn.setEnabled(bool(selected_rows))

    def _on_series_selection_changed(self, txt):
        \n 99. )

    def _enable_folder_rename_btn(self, *args):
        self.folder_rename_btn.setEnabled(True)

    def _on_album_selection_changed(self, selected, deselected):
        # Enable if any row is selected, else disable
        selected_rows = self.album_table.selectionModel().selectedRows()
        self.folder_rename_btn.setEnabled(bool(selected_rows))

    def _populate_albums(self, txt):
        if not txt:
            return
        self.album_table.clearContents()
        self.album_table.setRowCount(0)
        self.series_cover_url = \n100. )

class AlbumTable(QTableWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.main = parent
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.setDragEnabled(True)
        self.setColumnCount(1)
        self.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self._show_context_menu)

    def mouseMoveEvent(self, event):
        it = self.itemAt(event.pos())
        if not it:
            return
        print(f\n101. )
                    continue
                # Nettoie le nom du fichier (enlÃ¨ve les caractÃ¨res interdits)
                base_name = os.path.basename(src).replace(\n102. )
                    return
                for s in sorted(self.issues_by_series):
                    self.series_combo.addItem(f\n103. )
                else:
                    # Clear album table since we\n104. )
                self.issues_by_series = issues_by_series
                if not issues_by_series:
                    QMessageBox.warning(self, \n105. )
            else:
                print(f\n106. )
            return
        # Build new filename
        series = meta.get(\n107. )
            return
        # Clean up names
        clean = lambda s: \n108. )
            return
        current_folder = pathlib.Path(self.files[0][\n109. )
            return
        f = self.files[fr]
        itm = self.album_table.item(ar, 0)
        meta = itm.data(Qt.UserRole) if itm else None
        if not meta:
            QMessageBox.critical(self, \n110. )
            return
        if QMessageBox.question(self, \n111. )
            return
        itm = self.album_table.item(ar, 0)
        meta = itm.data(Qt.UserRole) if itm else None
        if not meta:
            QMessageBox.critical(self, \n112. )
        elif action == reveal_action:
            try:
                subprocess.Popen([\n113. )
        else:
            albums = []
            for album in series_list:
                s = album.get(\n114. )
        else:  # BDGest
            # Check if SeriesName checkbox is checked
            if self.series_name_cb.isChecked():
                # Use series-only search
                series_results = provider.search_series_only(q, debug=debug, verbose=verbose) \
                    if hasattr(provider, \n115. )
        for w in (self.source_combo, self.search_bar, self.search_btn, self.dir_btn, self.recursive_cb, self.settings_btn):
            ctrl.addWidget(w)
        layout.addLayout(ctrl)

        splitter_main = QSplitter(Qt.Horizontal)

        # --- Folder display ---
        file_panel = QWidget()
        file_panel_layout = QVBoxLayout(file_panel)
        file_panel_layout.setContentsMargins(0, 0, 0, 0)
        folder_display_layout = QHBoxLayout()
        self.folder_display = DraggableLineEdit()
        # Add the rename folder button
        self.folder_rename_btn = QPushButton(\n116. )
        self.dir_btn = QPushButton(\n117. )
        self.folder_rename_btn.setFixedWidth(30)
        self.folder_rename_btn.setEnabled(False)  # Disabled by default
        self.folder_rename_btn.clicked.connect(self._rename_folder_to_serie)
        folder_display_layout.addWidget(self.folder_display)
        folder_display_layout.addWidget(self.folder_rename_btn)
        file_panel_layout.addLayout(folder_display_layout)
        self.file_table = FileTable(self)
        self.file_table.setColumnCount(4)
        self.file_table.setHorizontalHeaderLabels([\n118. )
        self.folder_rename_btn.setToolTip(\n119. )
        self.folder_rename_btn.setToolTip(tr(\n120. )
        self.layout = QFormLayout(self)

        self.settings = settings or QSettings(\n121. )
        self.recursive_cb = QCheckBox(\n122. )
        self.rename_btn = QPushButton(\n123. )
        self.resize(1400, 800)
        self.settings = QSettings(\n124. )
        self.settings_btn.setFixedWidth(30)
        self.settings_btn.setToolTip(\n125. )
        self.settings_btn.setFixedWidth(30)
        self.settings_btn.setToolTip(tr(\n126. ))
                    return
                for s in sorted(self.issues_by_series):
                    self.series_combo.addItem(f\n127. ))
                return
            import shutil
            for src in files_to_add:
                # VÃ©rifie que le fichier existe
                if not os.path.exists(src):
                    QMessageBox.critical(self, tr(\n128. ))
                return
            op = \n129. ))
            return
        # Clean up names
        clean = lambda s: \n130. ))
            return
        # Extract serie_name
        serie_name = meta.get(\n131. ))
            return
        current_folder = pathlib.Path(self.files[0][\n132. ))
            return
        itm = self.album_table.item(ar, 0)
        meta = itm.data(Qt.UserRole) if itm else None
        if not meta:
            QMessageBox.critical(self, tr(\n133. ))
            self._cancel_editing()
            return
        
        # Check if folder with new name already exists
        new_folder_path = self._original_folder_path.parent / cleaned_name
        if new_folder_path.exists():
            QMessageBox.critical(self.main_window, tr(\n134. ))
        for w in (self.source_combo, self.search_bar, self.search_btn, self.dir_btn, self.recursive_cb, self.series_name_cb, self.settings_btn):
            ctrl.addWidget(w)
        layout.addLayout(ctrl)

        splitter_main = QSplitter(Qt.Horizontal)

        # --- Folder display ---
        file_panel = QWidget()
        file_panel_layout = QVBoxLayout(file_panel)
        file_panel_layout.setContentsMargins(0, 0, 0, 0)
        folder_display_layout = QHBoxLayout()
        self.folder_display = EditableFolderLineEdit(main_window=self)
        # Add the rename folder button
        self.folder_rename_btn = QPushButton(\n135. ))
        self.dir_btn = QPushButton(tr(\n136. ))
        self.folder_rename_btn.setFixedWidth(30)
        self.folder_rename_btn.setEnabled(False)  # Disabled by default
        self.folder_rename_btn.clicked.connect(self._rename_folder_to_serie)
        folder_display_layout.addWidget(self.folder_display)
        folder_display_layout.addWidget(self.folder_rename_btn)
        file_panel_layout.addLayout(folder_display_layout)
        self.file_table = FileTable(self)
        self.file_table.setColumnCount(4)
        self.file_table.setHorizontalHeaderLabels([\n137. ))
        self.layout = QFormLayout(self)

        self.settings = settings or QSettings(\n138. ))
        self.recursive_cb = QCheckBox(\n139. ))
        self.rename_btn = QPushButton(tr(\n140. ))
        self.resize(1400, 800)
        self.settings = QSettings(\n141. ))
        self.series_name_cb.setVisible(False)  # Hidden by default, shown only for BDGest
        self.settings_btn = QPushButton(\n142. )))

    def _rename_folder_to_serie(self):
        # Get current folder path
        if not self.files:
            QMessageBox.warning(self, \n143. )))

    def _rename_folder_to_serie(self):
        # Get current folder path
        if not self.files:
            QMessageBox.warning(self, tr(\n144. )))
        else:
            # If nothing selected, show root folder name
            self.folder_display.setText(os.path.basename(self.settings.value(\n145. ), str(e))

    def _open_settings(self):
        dlg = SettingsDialog(self, self.settings)
        if dlg.exec():
            # Invalidate BDGest session when settings change (credentials might have changed)
            bdgest_provider = PROVIDERS.get(\n146. ), str(e))
            return

        # External file drop (from Finder, etc.)
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            supported_exts = (\n147. ), tr(\n148. ).rstrip(\n149. ,
            r\n150. ,
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, content, re.MULTILINE)
            for match in matches:
                string_val = match.group(1)
                if self._is_translatable_string(string_val):
                    strings.add(string_val)
                    self._add_context(string_val, file_path, self._get_line_number(content, match.start()))
        
        return strings
    
    def _extract_ui_strings(self, content: str, file_path: str) -> Set[str]:
        \n151. , error=str(e)))
                self._cancel_editing()
                return
        
        # Reset to read-only mode
        self._reset_to_readonly()

    def _cancel_editing(self):
        \n152. , f\n153. , msg, QMessageBox.Yes | QMessageBox.No) != QMessageBox.Yes:
                return
            dest_folder = self.main.files[0][\n154. , msg, QMessageBox.Yes | QMessageBox.No) == QMessageBox.Yes:
            try:
                if not os.path.exists(str(f[\n155. , name=cleaned_name))
                
            except Exception as e:
                QMessageBox.critical(self.main_window, tr(\n156. , name=cleaned_name))
            self._cancel_editing()
            return
        
        # Confirm rename
        reply = QMessageBox.question(
            self.main_window,
            tr(\n157. , name=new_name))
                        return
                    os.rename(f[\n158. , name=new_name))
            return
        if QMessageBox.question(self, tr(\n159. , new_name=new_name), QMessageBox.Yes | QMessageBox.No) == QMessageBox.Yes:
            try:
                if not os.path.exists(str(f[\n160. , path=f[\n161. , path=src))
                    continue
                # Nettoie le nom du fichier (enlÃ¨ve les caractÃ¨res interdits)
                base_name = os.path.basename(src).replace(\n162. , str(e))

    def _show_context_menu(self, pos):
        row = self.rowAt(pos.y())
        if row < 0:
            return
        menu = QMenu(self)
        open_action = menu.addAction(\n163. /\\\n164. Ajouter des fichiers\n165. Album metadata missing\n166. Application Settings\n167. Aucun album trouvÃ© pour cette recherche sur BDGest.\n168. Aucun album trouvÃ© pour cette recherche.\n169. Aucun dossier actif pour l\n170. Aucun fichier dans le dossier.\n171. Aucun rÃ©sultat\n172. Aucune sÃ©rie trouvÃ©e pour cette recherche sur BDGest.\n173. Avertissement\n174. Comic Renamer - Multi-Source\n175. ComicsRename String Extraction Tool\n176. Constructed URL: {url}\n177. Could not open file:\n{e}\n178. Could not reveal file:\n{e}\n179. Couverture: {series[\n180. Dernier dossier utilisÃ©\n181. Details: {e}\n182. Disques externes (/Volumes)\n183. Dossier personnel\n184. Dossier renommÃ© en :\n{new_folder_name}\n185. Encoded Name: {encoded_series_name}\n186. Erreur\n187. Erreur lors du renommage du dossier :\n{e}\n188. Error\n189. Error processing {file_path}: {e}\n190. Error starting application: {e}\n191. Error: Missing dependencies. Please install requirements:\n192. Expected URL: {expected_url}\n193. Extract strings from QMessageBox calls\n194. Extract strings from addItem calls\n195. Extracting from: {file_path}\n196. Format non supportÃ©\n197. Impossible de dÃ©terminer le nom de la sÃ©rie.\n198. Info\n199. La fonction fetch_albums_by_series_id rÃ©cupÃ¨re maintenant les dÃ©tails des albums\n200. La fonctionnalitÃ© de renommage par double-clic est opÃ©rationnelle.\n201. Language Change\n202. Language will be applied after restarting the application.\n203. Le dossier porte dÃ©jÃ  ce nom.\n204. Le fichier source n\n205. Le systÃ¨me de gestion de session est opÃ©rationnel.\n206. Mot de passe configurÃ©: {\n207. MÃ©tadonnÃ©es de l\n208. No Results\n209. No albums found for this search.\n210. Nom: {series[\n211. OÃ¹ souhaitez-vous commencer la navigation ?\n212. ParamÃ¨tres\n213. ParamÃ¨tres de BDGestProvider.search_albums_by_series_id: {provider_params}\n214. ParamÃ¨tres de get_bdgest_albums_by_series_id: {params}\n215. Pays: {series[\n216. Please select one file and one album\n217. Rename\n218. Rename Error\n219. Renommer le dossier\n220. Renommer le dossier avec le nom de la sÃ©rie sÃ©lectionnÃ©e\n221. RÃ©sultat\n222. Scanning directory: {script_dir}\n223. Selection\n224. Series ID: {series_id}\n225. Series Name: {series_name}\n226. Seuls les fichiers PDF, EPUB, CBZ ou CBR sont acceptÃ©s.\n227. SuccÃ¨s\n228. SÃ©lection\n229. SÃ©lection du dossier\n230. Translation template saved to: {output_file}\n231. URL: {series[\n232. Un dossier nommÃ© \n233. Un fichier nommÃ© \n234. Utilisateur configurÃ©: {\n235. Valeur par dÃ©faut fetch_details dans provider: {provider_default}\n236. Valeur par dÃ©faut fetch_details: {default_fetch_details}\n237. Valeur par dÃ©faut max_workers: {default_max_workers}\n238. Veuillez sÃ©lectionner un album dans la liste.\n239. \nDÃ©tails complets:\n240. \nFor installation help, see:\n241. \nOr use the launcher scripts:\n242. \nPlease fix the issues above.\n243. \nTo start the application, run:\n244. \nâŒ¨ï¸ Raccourcis clavier:\n245. \nâš™ï¸  Checking configuration...\n246. \nâœ… All tests passed!\n247. \nâœ… Structure des fonctions correcte !\n248. \nâœ… Test terminÃ© avec succÃ¨s!\n249. \nâœ… Tests rÃ©ussis! La fonctionnalitÃ© de rÃ©cupÃ©ration d\n250. \nâŒ Certains tests ont Ã©chouÃ©.\n251. \nâŒ Test Ã©chouÃ©.\n252. \nğŸ‰ Test rÃ©ussi!\n253. \nğŸ‰ Tous les tests rÃ©ussis !\n254. \nğŸ¨ Indicateurs visuels:\n255. \nğŸ¯ Top 10 strings to translate:\n256. \nğŸ’¡ If dependencies are missing, try:\n257. \nğŸ’¡ Pour tester:\n258. \nğŸ“ Checking project files...\n259. \nğŸ“ Output files created in: {output_dir}\n260. \nğŸ“Š Extraction Results:\n261. \nğŸ“‹ Avantages de la nouvelle implÃ©mentation:\n262. \nğŸ“‹ Workflow complet:\n263. \nğŸ“š Albums trouvÃ©s:\n264. \nğŸ“š SÃ©rie #{i}\n265. \nğŸ“¦ Checking dependencies...\n266. \nğŸ”„ Comportement:\n267. \nğŸ” FonctionnalitÃ©s d\n268. \nğŸ” Test des mÃ©thodes de gestion de session:\n269. \nğŸ” Testing function availability...\n270. \nğŸ”‘ Test de rÃ©cupÃ©ration des identifiants:\n271. \nğŸ”§ Testing module imports...\n272. \nğŸ–¥ï¸  Checking GUI availability...\n273. \nğŸ›¡ï¸ Protections implÃ©mentÃ©es:\n274. ])
        default_provider = self.settings.value(\n275. ])
        idx = self.provider_combo.findText(self.default_provider)
        if idx >= 0:
            self.provider_combo.setCurrentIndex(idx)
        self.provider_combo.setCurrentIndex(idx if idx >= 0 else 0)

        self.files = []
        self._source = self.provider_combo.currentText()
        self.issues_by_series = defaultdict(list)
        self._populating = False
        self._bdgest_album_results = []
        self._bdgest_series_results = []  # New: store series search results
        self._original_cover_pixmap = None  # Store original pixmap for rescaling
        self._build_ui()
        self.series_cover_url = \n276. ])
        idx = self.provider_combo.findText(self.default_provider)
        if idx >= 0:
            self.provider_combo.setCurrentIndex(idx)
        self.provider_combo.setCurrentIndex(idx if idx >= 0 else 0)

        self.files = []
        self._source = self.provider_combo.currentText()
        self.issues_by_series = defaultdict(list)
        self._populating = False
        self._bdgest_album_results = []
        self._build_ui()
        self.series_cover_url = \n277. ])
        self.search_bar = DroppableLineEdit()
        self.search_btn = QPushButton(\n278. ])
        self.search_bar = DroppableLineEdit()
        self.search_btn = QPushButton(tr(\n279. ]))
                        return
                    if new_path.exists():
                        QMessageBox.critical(self, tr(\n280. ]))
                    return
                os.rename(str(f[\n281. ]}\n282. album manquantes.\n283. exactement comme fetch_albums.\n284. existe pas:\n{f[\n285. import.\n286. pip install -r requirements.txt\n287. {new_name}\n288. Ã‰tat initial - AuthentifiÃ©: {provider._authenticated}\n289. Ã‰tat initial - Derniers identifiants: {provider._last_credentials}\n290. Ã‰tat initial - Session: {provider._session}\n291. â° DÃ©but: {datetime.now().strftime(\n292. â±ï¸  DurÃ©e: {(end_time - start_time).total_seconds():.2f}s\n293. âš ï¸  ClÃ© ComicVine manquante (optionnel pour BDGest seulement)\n294. âš ï¸  Fichier .env manquant\n295. âš ï¸  {var} manquant\n296. âœ… .env protÃ©gÃ© dans .gitignore\n297. âœ… BDGestProvider crÃ©Ã©\n298. âœ… BDGestProvider utilise fetch_details=True par dÃ©faut\n299. âœ… BDGestProvider.search_albums_by_series_id method available\n300. âœ… Classes importÃ©es avec succÃ¨s\n301. âœ… Configuration sauvegardÃ©e dans .env\n302. âœ… Fichier .env trouvÃ©\n303. âœ… Import de get_bdgest_albums_by_series_id rÃ©ussi\n304. âœ… ParamÃ¨tre fetch_details prÃ©sent\n305. âœ… ParamÃ¨tre max_workers prÃ©sent\n306. âœ… Series ID correctly placed in \n307. âœ… Series name correctly placed in \n308. âœ… fetch_details=True par dÃ©faut\n309. âœ… get_bdgest_albums_by_series_id imported successfully\n310. âœ… max_workers=4 par dÃ©faut\n311. âœ… {len(albums)} album(s) trouvÃ©(s) pour la sÃ©rie \n312. âœ… {len(series_list)} sÃ©rie(s) trouvÃ©e(s):\n313. âœ… {len(series_results)} sÃ©rie(s) trouvÃ©e(s)\n314. âœ… {method} disponible\n315. âœ… {method}: {description}\n316. âœ… {var} configurÃ©\n317. âŒ .env non protÃ©gÃ© dans .gitignore\n318. âŒ .gitignore manquant\n319. âŒ Aucun ID de sÃ©rie trouvÃ© dans les rÃ©sultats\n320. âŒ Aucun album trouvÃ© pour la sÃ©rie \n321. âŒ Aucune sÃ©rie trouvÃ©e pour \n322. âŒ Aucune sÃ©rie trouvÃ©e.\n323. âŒ BDGestProvider devrait utiliser fetch_details=True par dÃ©faut\n324. âŒ BDGestProvider.search_albums_by_series_id method not found\n325. âŒ Configuration annulÃ©e.\n326. âŒ Erreur d\n327. âŒ Erreur lors de la rÃ©cupÃ©ration des identifiants: {e}\n328. âŒ Erreur lors de la sauvegarde: {e}\n329. âŒ Erreur lors des tests: {e}\n330. âŒ Erreur lors du test: {e}\n331. âŒ Erreur: Nom d\n332. âŒ Error during testing: {e}\n333. âŒ Identifiants BDGest manquants.\n334. âŒ ParamÃ¨tre fetch_details manquant\n335. âŒ ParamÃ¨tre max_workers manquant\n336. âŒ Series ID not found in \n337. âŒ Series name not found in \n338. âŒ fetch_details devrait Ãªtre True par dÃ©faut\n339. âŒ max_workers devrait Ãªtre 4 par dÃ©faut\n340. âŒ {len(failed_checks)} check(s) failed:\n341. âŒ {method} manquante\n342. âŒ {method}: MANQUANT\n343. ğŸ‰ All checks passed! ComicsRename is ready to use.\n344. ğŸ‰ Configuration de sÃ©curitÃ© optimale !\n345. ğŸ‰ Configuration terminÃ©e !\n346. ğŸ Checking Python version...\n347. ğŸ“ Les albums rÃ©cupÃ©rÃ©s auront maintenant un champ \n348. ğŸ“ Veuillez entrer vos identifiants:\n349. ğŸ” ComicsRename Installation Validator\n350. ğŸ” Recherche de sÃ©ries avec le terme: \n351. ğŸ” Test 1: Recherche de sÃ©ries...\n352. ğŸ” Test 2: RÃ©cupÃ©ration des albums pour la sÃ©rie \n353. ğŸ” Test de la structure des donnÃ©es d\n354. ğŸ” Testing URL construction...\n355. ğŸ” VÃ©rification de SÃ©curitÃ©\n356. ğŸ” Configuration SÃ©curisÃ©e des Identifiants\n357. ğŸ”’ Permissions sÃ©curisÃ©es appliquÃ©es\n358. ğŸ”§ Actions RecommandÃ©es:\n359. ğŸ”§ ParamÃ¨tres de test:\n360. ğŸ”¸ BDGest (www.bedetheque.com)\n361. ğŸ”¸ ComicVine (comicvine.gamespot.com)\n362. ğŸ§ª Test de gestion de session BDGest\n363. ğŸ§ª Test de renommage de dossier par double-clic\n364. ğŸ§ª Test de rÃ©cupÃ©ration d\n365. ğŸ§ª Test de rÃ©cupÃ©ration des dÃ©tails d\n